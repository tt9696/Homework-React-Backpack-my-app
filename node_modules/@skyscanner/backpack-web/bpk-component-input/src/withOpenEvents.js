/*
 * Backpack - Skyscanner's Design System
 *
 * Copyright 2016 Skyscanner Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Component } from 'react';
import { wrapDisplayName } from "../../bpk-react-utils";
import { jsx as _jsx } from "react/jsx-runtime";
const KEYCODES = {
  ENTER: 'Enter',
  SPACEBAR: 'Space'
};
const handleKeyEvent = callback => e => {
  if (e.code === KEYCODES.ENTER || e.code === KEYCODES.SPACEBAR) {
    e.preventDefault();
    if (callback) {
      callback();
    }
  }
};
const withEventHandler = (fn, eventHandler) => e => {
  if (fn) {
    fn(e);
  }
  if (eventHandler) {
    eventHandler(e);
  }
};
const withOpenEvents = WithOpenEventsInputComponent => {
  class WithOpenEvents extends Component {
    static defaultProps = {
      // Custom props
      isOpen: false,
      hasTouchSupport: !!(typeof window !== 'undefined' && 'ontouchstart' in window),
      onOpen: null,
      // Input props
      onClick: null,
      onFocus: null,
      onBlur: null,
      onTouchEnd: null,
      onKeyDown: null,
      onKeyUp: null
    };
    constructor(props) {
      super(props);
      this.focusCanOpen = true;
    }
    handleTouchEnd = event => {
      // preventDefault fixes an issue on Android and iOS in which the popover closes immediately
      // because a touch event is registered on one of the dates.
      // We can only run preventDefault when the input is already focused - otherwise it would never set
      // focus on it, and when closing the modal/popover focus would return to the previously focused
      // element (which is annoying if it's an autosuggest or another datepicker, for example).
      if (document && event.target === document.activeElement) {
        event.preventDefault();
        if (this.props.onOpen) {
          this.props.onOpen();
        }
      }
    };
    handleFocus = () => {
      if (this.focusCanOpen && this.props.onOpen) {
        this.props.onOpen();
      }
    };
    handleBlur = () => {
      // If the input loses focus when the target is open, it should not open on a subsequent focus.
      // Fixes an issue with IE9.
      if (this.props.isOpen) {
        this.focusCanOpen = false;
      } else {
        this.focusCanOpen = true;
      }
    };
    render() {
      const {
        className,
        hasTouchSupport,
        isOpen,
        onBlur,
        onClick,
        onFocus,
        onKeyDown,
        onKeyUp,
        onOpen,
        onTouchEnd,
        ...rest
      } = this.props;
      const eventHandlers = {
        onClick: withEventHandler(onOpen, onClick),
        // @ts-expect-error for some reason the type KeyboardEvent was not being recognized as
        // a valid type to UIEvent even though it is a valid subtype type of UIEvent
        onKeyDown: withEventHandler(handleKeyEvent(onOpen), onKeyDown)
      };
      if (hasTouchSupport) {
        // Prevents the mobile keyboard from opening (iOS / Android), while not announcing it as 'read only' to a screen reader
        eventHandlers.readOnly = 'readOnly';
        eventHandlers['aria-readonly'] = false;
        eventHandlers.onTouchEnd = withEventHandler(this.handleTouchEnd, onTouchEnd);
      }

      // Needed on desktop to allow the intended behaviour of opening on focus
      // Needed on mobile as some Android devices do not trigger onClick or onTouch when TalkBack is active but do trigger onFocus
      eventHandlers.onFocus = withEventHandler(this.handleFocus, onFocus);
      eventHandlers.onBlur = withEventHandler(this.handleBlur, onBlur);
      return /*#__PURE__*/_jsx(WithOpenEventsInputComponent, {
        className: className,
        ...eventHandlers,
        ...rest,
        "data-openable": true // This allows for conditional styling within BpkInput
      });
    }
  }
  WithOpenEvents.displayName = wrapDisplayName(WithOpenEventsInputComponent, 'withOpenEvents');
  return WithOpenEvents;
};
export default withOpenEvents;