/*
 * Backpack - Skyscanner's Design System
 *
 * Copyright 2016 Skyscanner Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Component, createElement as _createElement } from 'react';
import { cssModules, isRTL } from "../../bpk-react-utils";
import { addMonths, isSameMonth, formatIsoMonth, differenceInCalendarMonths, dateToBoundaries, startOfDay, setMonthYear, isWithinRange, getMonthRange } from "./date-utils";
import { getCalendarGridWidth, getTransformStyles, isTransitionEndSupported } from "./utils";
import STYLES from "./BpkCalendarGridTransition.module.css";
import { jsx as _jsx } from "react/jsx-runtime";
const getClassName = cssModules(STYLES);
const transitionValues = {
  previous: '0px',
  current: getCalendarGridWidth(-1),
  next: getCalendarGridWidth(-2)
};
const getFocusedDateForMonth = (month, currentFocusedDate, minDate, maxDate) => dateToBoundaries(setMonthYear(currentFocusedDate, month.getMonth(), month.getFullYear()), startOfDay(minDate), startOfDay(maxDate));
class BpkCalendarGridTransition extends Component {
  static defaultProps = {
    className: null,
    month: new Date(),
    focusedDate: null
  };
  constructor(props) {
    super(props);
    const {
      month = new Date()
    } = props;
    this.onMonthTransitionEnd = this.onMonthTransitionEnd.bind(this);
    this.state = {
      isTransitioning: false,
      transitionValue: transitionValues.current,
      // Used in a test so this is valid usage.
      // eslint-disable-next-line react/no-unused-state
      currentMonth: props.month,
      months: [addMonths(month, -1), month, addMonths(month, 1)]
    };
    this.isTransitionEndSupported = isTransitionEndSupported();
  }
  UNSAFE_componentWillReceiveProps({
    month: nextMonth = new Date()
  }) {
    const {
      month = new Date()
    } = this.props;
    const hasMonthChanged = !isSameMonth(month, nextMonth);
    if (hasMonthChanged) {
      const reverse = isRTL();
      if (differenceInCalendarMonths(nextMonth, month) === 1) {
        // Transition to next month
        this.setState({
          transitionValue: reverse ? transitionValues.previous : transitionValues.next,
          isTransitioning: true
        });
        return;
      }
      if (differenceInCalendarMonths(nextMonth, month) === -1) {
        // Transition to previous month
        this.setState({
          transitionValue: reverse ? transitionValues.next : transitionValues.previous,
          isTransitioning: true
        });
        return;
      }
      this.setState({
        // Used in a test so this is valid usage.
        // eslint-disable-next-line react/no-unused-state
        currentMonth: nextMonth,
        months: [addMonths(nextMonth, -1), nextMonth, addMonths(nextMonth, 1)]
      });
    }
  }
  componentDidUpdate() {
    // For IE9, immediately call onMonthTransitionEnd instead of
    // waiting for the animation to complete
    // Thx to Airbnb's react-dates <3
    if (!this.isTransitionEndSupported && this.state.isTransitioning) {
      this.onMonthTransitionEnd();
    }
  }
  onMonthTransitionEnd() {
    const {
      month = new Date()
    } = this.props;
    this.setState({
      transitionValue: transitionValues.current,
      isTransitioning: false,
      // Used in a test so this is valid usage.
      // eslint-disable-next-line react/no-unused-state
      currentMonth: month,
      months: [addMonths(month, -1), month, addMonths(month, 1)]
    });
  }
  render() {
    const {
      TransitionComponent,
      className = null,
      focusedDate = null,
      ...rest
    } = this.props;
    const {
      isTransitioning,
      transitionValue
    } = this.state;
    const stripClassNames = getClassName('bpk-calendar-grid-transition__strip', isTransitioning && 'bpk-calendar-grid-transition__strip--transitioning');
    let min;
    let max;
    if (rest.minDate && rest.maxDate) {
      ({
        max,
        min
      } = getMonthRange(rest.minDate, rest.maxDate));
    }
    return /*#__PURE__*/_jsx("div", {
      className: getClassName('bpk-calendar-grid-transition', className),
      children: /*#__PURE__*/_jsx("div", {
        className: stripClassNames,
        style: getTransformStyles(transitionValue),
        onTransitionEnd: this.onMonthTransitionEnd,
        children: this.state.months.map((m, index) => min && max && isWithinRange(m, {
          start: min,
          end: max
        }) ? /*#__PURE__*/_createElement(TransitionComponent, {
          ...rest,
          key: formatIsoMonth(m),
          month: m,
          preventKeyboardFocus: index !== 1 || rest.preventKeyboardFocus,
          isKeyboardFocusable: !isTransitioning && index === 1,
          focusedDate: index === 1 ? focusedDate : getFocusedDateForMonth(m, focusedDate, rest.minDate, rest.maxDate),
          "aria-hidden": index !== 1,
          className: getClassName('bpk-calendar-grid-transition__grid')
        }) : /*#__PURE__*/_jsx("div", {
          className: getClassName('bpk-calendar-grid-transition__dummy')
        }, formatIsoMonth(m)))
      })
    });
  }
}
const addCalendarGridTransition = TransitionComponent => props => /*#__PURE__*/_jsx(BpkCalendarGridTransition, {
  ...props,
  TransitionComponent: TransitionComponent
});
export default BpkCalendarGridTransition;
export { addCalendarGridTransition };