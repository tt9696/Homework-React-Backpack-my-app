{"ast":null,"code":"/*\n * Backpack - Skyscanner's Design System\n *\n * Copyright 2016 Skyscanner Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Component } from 'react';\nimport { isRTL } from \"../../bpk-react-utils\";\nimport BpkCalendarDate from \"./BpkCalendarDate\";\nimport { BpkCalendarGridWithTransition } from \"./BpkCalendarGrid\";\nimport BpkCalendarGridHeader from \"./BpkCalendarGridHeader\";\nimport BpkCalendarNav from \"./BpkCalendarNav\";\nimport composeCalendar from \"./composeCalendar\";\nimport { CALENDAR_SELECTION_TYPE } from \"./custom-proptypes\";\nimport { addDays, addMonths, dateToBoundaries, isAfter, isSameMonth, isSameDay, lastDayOfMonth, setMonthYear, startOfDay, startOfMonth } from \"./date-utils\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n/**\n * Updates the current focused date\n * @param {Object} currentProps current input properties\n * @param {Object} nextProps next input properties when component changes\n * @returns {Boolean} if the selected date has changed\n */\nconst focusedDateHasChanged = (currentProps, nextProps) => {\n  const currentSelectConfig = currentProps.selectionConfiguration;\n  const nextSelectConfig = nextProps.selectionConfiguration;\n  const rawNextSelectedDate = nextSelectConfig.type === CALENDAR_SELECTION_TYPE.single ? nextSelectConfig.date : nextSelectConfig.startDate;\n  const rawSelectedDate = currentSelectConfig.type === CALENDAR_SELECTION_TYPE.single ? currentSelectConfig.date : currentSelectConfig.startDate;\n  if (!rawSelectedDate && !rawNextSelectedDate) {\n    return false;\n  }\n  if (rawSelectedDate && !rawNextSelectedDate || !rawSelectedDate && rawNextSelectedDate) {\n    return true;\n  }\n\n  // @ts-expect-error TS reporting incorrectly as we are already checking above that the dates are not null\n  return !isSameDay(rawNextSelectedDate, rawSelectedDate);\n};\n\n/**\n * Determines the focused date on the calendar\n * @param {Date} rawSelectedDate the raw date provided to the calendar to be selected\n * @param {Date} initiallyFocusedDate inital date that was selected\n * @param {Date} minDate min available date to be selectable in the calendar\n * @param {Date} maxDate max available date to be selectable in the calendar\n * @returns {Date} which date to be focused on the calendar when it loads\n */\nconst determineFocusedDate = (rawSelectedDate, initiallyFocusedDate, minDate, maxDate) => {\n  if (rawSelectedDate) {\n    return dateToBoundaries(rawSelectedDate, minDate, maxDate);\n  }\n  if (initiallyFocusedDate) {\n    return dateToBoundaries(initiallyFocusedDate, minDate, maxDate);\n  }\n  return minDate;\n};\n\n/**\n * Function that based on the configuration will return a single date or start and end date.\n * @param {Object} selectionConfig - The configuration of calendar to be used\n * @returns {Array} An array or single of multiple dates\n */\nconst getRawSelectedDate = selectionConfig => {\n  let rawDate = [];\n  switch (selectionConfig.type) {\n    case CALENDAR_SELECTION_TYPE.single:\n      rawDate = [selectionConfig.date];\n      break;\n    case CALENDAR_SELECTION_TYPE.range:\n      rawDate = [selectionConfig.startDate, selectionConfig.endDate];\n      break;\n    default:\n      rawDate = [null];\n      break;\n  }\n  return rawDate;\n};\nconst withCalendarState = Calendar => {\n  class BpkCalendarContainer extends Component {\n    static defaultProps = {\n      fixedWidth: true,\n      maxDate: addMonths(new Date(), 12),\n      minDate: new Date(),\n      onDateSelect: null,\n      onMonthChange: null,\n      selectionConfiguration: {\n        type: CALENDAR_SELECTION_TYPE.single,\n        date: null\n      },\n      initiallyFocusedDate: null,\n      markToday: true,\n      markOutsideDays: true\n    };\n    constructor(props) {\n      super(props);\n      const minDate = startOfDay(this.props.minDate);\n      const maxDate = startOfDay(this.props.maxDate);\n      const rawSelectedDate = getRawSelectedDate(this.props.selectionConfiguration);\n      const {\n        initiallyFocusedDate\n      } = this.props;\n      this.state = {\n        preventKeyboardFocus: true,\n        focusedDate: determineFocusedDate(rawSelectedDate[0], initiallyFocusedDate, minDate, maxDate)\n      };\n    }\n    UNSAFE_componentWillReceiveProps(nextProps) {\n      const rawNextSelectedDate = getRawSelectedDate(nextProps.selectionConfiguration);\n      const minDate = startOfDay(nextProps.minDate);\n      const maxDate = startOfDay(nextProps.maxDate);\n      if (focusedDateHasChanged(this.props, nextProps)) {\n        this.setState({\n          focusedDate: dateToBoundaries(rawNextSelectedDate[0], minDate, maxDate)\n        });\n      }\n    }\n    handleDateFocus = (event, {\n      date,\n      source\n    }) => {\n      const {\n        onMonthChange\n      } = this.props;\n      const focusedDate = dateToBoundaries(date, startOfDay(this.props.minDate), startOfDay(this.props.maxDate));\n      const didMonthChange = !isSameMonth(this.state.focusedDate, focusedDate);\n      this.setState({\n        preventKeyboardFocus: false,\n        focusedDate\n      }, () => {\n        if (onMonthChange && didMonthChange) {\n          onMonthChange(event, {\n            month: startOfMonth(focusedDate),\n            source\n          });\n        }\n      });\n    };\n    handleDateSelect = date => {\n      const {\n        onDateSelect,\n        selectionConfiguration\n      } = this.props;\n      const keyboardFocusState = {\n        preventKeyboardFocus: false\n      };\n      if (onDateSelect) {\n        const newDate = dateToBoundaries(date, startOfDay(this.props.minDate), startOfDay(this.props.maxDate));\n        if (selectionConfiguration && selectionConfiguration.type === CALENDAR_SELECTION_TYPE.range && selectionConfiguration.startDate && !selectionConfiguration.endDate && (isAfter(newDate, selectionConfiguration.startDate) || isSameDay(newDate, selectionConfiguration.startDate))) {\n          onDateSelect(selectionConfiguration.startDate, newDate);\n        } else {\n          onDateSelect(newDate);\n        }\n      } else {\n        this.setState(keyboardFocusState);\n      }\n    };\n    handleMonthChange = (event, {\n      month,\n      source\n    }) => {\n      this.handleDateFocus(event, {\n        date: setMonthYear(this.state.focusedDate, month.getMonth(), month.getFullYear()),\n        source\n      });\n    };\n    handleDateKeyDown = event => {\n      const reverse = isRTL() ? -1 : 1;\n      const {\n        focusedDate\n      } = this.state;\n      const source = 'GRID';\n      let preventDefault = true;\n      switch (event.key) {\n        case 'ArrowRight':\n          this.handleDateFocus(event, {\n            date: addDays(focusedDate, reverse * 1),\n            source\n          });\n          break;\n        case 'ArrowLeft':\n          this.handleDateFocus(event, {\n            date: addDays(focusedDate, reverse * -1),\n            source\n          });\n          break;\n        case 'ArrowUp':\n          this.handleDateFocus(event, {\n            date: addDays(focusedDate, -7),\n            source\n          });\n          break;\n        case 'ArrowDown':\n          this.handleDateFocus(event, {\n            date: addDays(focusedDate, 7),\n            source\n          });\n          break;\n        case 'PageUp':\n          this.handleDateFocus(event, {\n            date: addMonths(focusedDate, -1),\n            source\n          });\n          break;\n        case 'PageDown':\n          this.handleDateFocus(event, {\n            date: addMonths(focusedDate, 1),\n            source\n          });\n          break;\n        case 'Home':\n          this.handleDateFocus(event, {\n            date: startOfMonth(focusedDate),\n            source\n          });\n          break;\n        case 'End':\n          this.handleDateFocus(event, {\n            date: lastDayOfMonth(focusedDate),\n            source\n          });\n          break;\n        default:\n          preventDefault = false;\n          break;\n      }\n      if (preventDefault) {\n        event.preventDefault();\n      }\n    };\n    render() {\n      const {\n        maxDate,\n        minDate,\n        onDateSelect,\n        onMonthChange,\n        selectionConfiguration,\n        ...calendarProps\n      } = this.props;\n      const sanitisedMinDate = startOfDay(minDate);\n      const sanitisedMaxDate = startOfDay(maxDate);\n      const sanitisedFocusedDate = dateToBoundaries(this.state.focusedDate, sanitisedMinDate, sanitisedMaxDate);\n      const month = startOfMonth(sanitisedFocusedDate);\n      return /*#__PURE__*/_jsx(Calendar, {\n        onMonthChange: this.handleMonthChange,\n        onDateClick: this.handleDateSelect,\n        month: month,\n        onDateKeyDown: this.handleDateKeyDown,\n        preventKeyboardFocus: this.state.preventKeyboardFocus,\n        focusedDate: sanitisedFocusedDate,\n        ...calendarProps,\n        minDate: sanitisedMinDate,\n        maxDate: sanitisedMaxDate,\n        selectionConfiguration: selectionConfiguration\n      });\n    }\n  }\n  return BpkCalendarContainer;\n};\nexport default withCalendarState(composeCalendar(BpkCalendarNav, BpkCalendarGridHeader, BpkCalendarGridWithTransition, BpkCalendarDate));\nexport { withCalendarState };","map":{"version":3,"names":["Component","isRTL","BpkCalendarDate","BpkCalendarGridWithTransition","BpkCalendarGridHeader","BpkCalendarNav","composeCalendar","CALENDAR_SELECTION_TYPE","addDays","addMonths","dateToBoundaries","isAfter","isSameMonth","isSameDay","lastDayOfMonth","setMonthYear","startOfDay","startOfMonth","jsx","_jsx","focusedDateHasChanged","currentProps","nextProps","currentSelectConfig","selectionConfiguration","nextSelectConfig","rawNextSelectedDate","type","single","date","startDate","rawSelectedDate","determineFocusedDate","initiallyFocusedDate","minDate","maxDate","getRawSelectedDate","selectionConfig","rawDate","range","endDate","withCalendarState","Calendar","BpkCalendarContainer","defaultProps","fixedWidth","Date","onDateSelect","onMonthChange","markToday","markOutsideDays","constructor","props","state","preventKeyboardFocus","focusedDate","UNSAFE_componentWillReceiveProps","setState","handleDateFocus","event","source","didMonthChange","month","handleDateSelect","keyboardFocusState","newDate","handleMonthChange","getMonth","getFullYear","handleDateKeyDown","reverse","preventDefault","key","render","calendarProps","sanitisedMinDate","sanitisedMaxDate","sanitisedFocusedDate","onDateClick","onDateKeyDown"],"sources":["C:/Users/Dell/my-app/node_modules/@skyscanner/backpack-web/bpk-component-calendar/src/BpkCalendarContainer.js"],"sourcesContent":["/*\n * Backpack - Skyscanner's Design System\n *\n * Copyright 2016 Skyscanner Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Component } from 'react';\nimport { isRTL } from \"../../bpk-react-utils\";\nimport BpkCalendarDate from \"./BpkCalendarDate\";\nimport { BpkCalendarGridWithTransition } from \"./BpkCalendarGrid\";\nimport BpkCalendarGridHeader from \"./BpkCalendarGridHeader\";\nimport BpkCalendarNav from \"./BpkCalendarNav\";\nimport composeCalendar from \"./composeCalendar\";\nimport { CALENDAR_SELECTION_TYPE } from \"./custom-proptypes\";\nimport { addDays, addMonths, dateToBoundaries, isAfter, isSameMonth, isSameDay, lastDayOfMonth, setMonthYear, startOfDay, startOfMonth } from \"./date-utils\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n/**\n * Updates the current focused date\n * @param {Object} currentProps current input properties\n * @param {Object} nextProps next input properties when component changes\n * @returns {Boolean} if the selected date has changed\n */\nconst focusedDateHasChanged = (currentProps, nextProps) => {\n  const currentSelectConfig = currentProps.selectionConfiguration;\n  const nextSelectConfig = nextProps.selectionConfiguration;\n  const rawNextSelectedDate = nextSelectConfig.type === CALENDAR_SELECTION_TYPE.single ? nextSelectConfig.date : nextSelectConfig.startDate;\n  const rawSelectedDate = currentSelectConfig.type === CALENDAR_SELECTION_TYPE.single ? currentSelectConfig.date : currentSelectConfig.startDate;\n  if (!rawSelectedDate && !rawNextSelectedDate) {\n    return false;\n  }\n  if (rawSelectedDate && !rawNextSelectedDate || !rawSelectedDate && rawNextSelectedDate) {\n    return true;\n  }\n\n  // @ts-expect-error TS reporting incorrectly as we are already checking above that the dates are not null\n  return !isSameDay(rawNextSelectedDate, rawSelectedDate);\n};\n\n/**\n * Determines the focused date on the calendar\n * @param {Date} rawSelectedDate the raw date provided to the calendar to be selected\n * @param {Date} initiallyFocusedDate inital date that was selected\n * @param {Date} minDate min available date to be selectable in the calendar\n * @param {Date} maxDate max available date to be selectable in the calendar\n * @returns {Date} which date to be focused on the calendar when it loads\n */\nconst determineFocusedDate = (rawSelectedDate, initiallyFocusedDate, minDate, maxDate) => {\n  if (rawSelectedDate) {\n    return dateToBoundaries(rawSelectedDate, minDate, maxDate);\n  }\n  if (initiallyFocusedDate) {\n    return dateToBoundaries(initiallyFocusedDate, minDate, maxDate);\n  }\n  return minDate;\n};\n\n/**\n * Function that based on the configuration will return a single date or start and end date.\n * @param {Object} selectionConfig - The configuration of calendar to be used\n * @returns {Array} An array or single of multiple dates\n */\nconst getRawSelectedDate = selectionConfig => {\n  let rawDate = [];\n  switch (selectionConfig.type) {\n    case CALENDAR_SELECTION_TYPE.single:\n      rawDate = [selectionConfig.date];\n      break;\n    case CALENDAR_SELECTION_TYPE.range:\n      rawDate = [selectionConfig.startDate, selectionConfig.endDate];\n      break;\n    default:\n      rawDate = [null];\n      break;\n  }\n  return rawDate;\n};\nconst withCalendarState = Calendar => {\n  class BpkCalendarContainer extends Component {\n    static defaultProps = {\n      fixedWidth: true,\n      maxDate: addMonths(new Date(), 12),\n      minDate: new Date(),\n      onDateSelect: null,\n      onMonthChange: null,\n      selectionConfiguration: {\n        type: CALENDAR_SELECTION_TYPE.single,\n        date: null\n      },\n      initiallyFocusedDate: null,\n      markToday: true,\n      markOutsideDays: true\n    };\n    constructor(props) {\n      super(props);\n      const minDate = startOfDay(this.props.minDate);\n      const maxDate = startOfDay(this.props.maxDate);\n      const rawSelectedDate = getRawSelectedDate(this.props.selectionConfiguration);\n      const {\n        initiallyFocusedDate\n      } = this.props;\n      this.state = {\n        preventKeyboardFocus: true,\n        focusedDate: determineFocusedDate(rawSelectedDate[0], initiallyFocusedDate, minDate, maxDate)\n      };\n    }\n    UNSAFE_componentWillReceiveProps(nextProps) {\n      const rawNextSelectedDate = getRawSelectedDate(nextProps.selectionConfiguration);\n      const minDate = startOfDay(nextProps.minDate);\n      const maxDate = startOfDay(nextProps.maxDate);\n      if (focusedDateHasChanged(this.props, nextProps)) {\n        this.setState({\n          focusedDate: dateToBoundaries(rawNextSelectedDate[0], minDate, maxDate)\n        });\n      }\n    }\n    handleDateFocus = (event, {\n      date,\n      source\n    }) => {\n      const {\n        onMonthChange\n      } = this.props;\n      const focusedDate = dateToBoundaries(date, startOfDay(this.props.minDate), startOfDay(this.props.maxDate));\n      const didMonthChange = !isSameMonth(this.state.focusedDate, focusedDate);\n      this.setState({\n        preventKeyboardFocus: false,\n        focusedDate\n      }, () => {\n        if (onMonthChange && didMonthChange) {\n          onMonthChange(event, {\n            month: startOfMonth(focusedDate),\n            source\n          });\n        }\n      });\n    };\n    handleDateSelect = date => {\n      const {\n        onDateSelect,\n        selectionConfiguration\n      } = this.props;\n      const keyboardFocusState = {\n        preventKeyboardFocus: false\n      };\n      if (onDateSelect) {\n        const newDate = dateToBoundaries(date, startOfDay(this.props.minDate), startOfDay(this.props.maxDate));\n        if (selectionConfiguration && selectionConfiguration.type === CALENDAR_SELECTION_TYPE.range && selectionConfiguration.startDate && !selectionConfiguration.endDate && (isAfter(newDate, selectionConfiguration.startDate) || isSameDay(newDate, selectionConfiguration.startDate))) {\n          onDateSelect(selectionConfiguration.startDate, newDate);\n        } else {\n          onDateSelect(newDate);\n        }\n      } else {\n        this.setState(keyboardFocusState);\n      }\n    };\n    handleMonthChange = (event, {\n      month,\n      source\n    }) => {\n      this.handleDateFocus(event, {\n        date: setMonthYear(this.state.focusedDate, month.getMonth(), month.getFullYear()),\n        source\n      });\n    };\n    handleDateKeyDown = event => {\n      const reverse = isRTL() ? -1 : 1;\n      const {\n        focusedDate\n      } = this.state;\n      const source = 'GRID';\n      let preventDefault = true;\n      switch (event.key) {\n        case 'ArrowRight':\n          this.handleDateFocus(event, {\n            date: addDays(focusedDate, reverse * 1),\n            source\n          });\n          break;\n        case 'ArrowLeft':\n          this.handleDateFocus(event, {\n            date: addDays(focusedDate, reverse * -1),\n            source\n          });\n          break;\n        case 'ArrowUp':\n          this.handleDateFocus(event, {\n            date: addDays(focusedDate, -7),\n            source\n          });\n          break;\n        case 'ArrowDown':\n          this.handleDateFocus(event, {\n            date: addDays(focusedDate, 7),\n            source\n          });\n          break;\n        case 'PageUp':\n          this.handleDateFocus(event, {\n            date: addMonths(focusedDate, -1),\n            source\n          });\n          break;\n        case 'PageDown':\n          this.handleDateFocus(event, {\n            date: addMonths(focusedDate, 1),\n            source\n          });\n          break;\n        case 'Home':\n          this.handleDateFocus(event, {\n            date: startOfMonth(focusedDate),\n            source\n          });\n          break;\n        case 'End':\n          this.handleDateFocus(event, {\n            date: lastDayOfMonth(focusedDate),\n            source\n          });\n          break;\n        default:\n          preventDefault = false;\n          break;\n      }\n      if (preventDefault) {\n        event.preventDefault();\n      }\n    };\n    render() {\n      const {\n        maxDate,\n        minDate,\n        onDateSelect,\n        onMonthChange,\n        selectionConfiguration,\n        ...calendarProps\n      } = this.props;\n      const sanitisedMinDate = startOfDay(minDate);\n      const sanitisedMaxDate = startOfDay(maxDate);\n      const sanitisedFocusedDate = dateToBoundaries(this.state.focusedDate, sanitisedMinDate, sanitisedMaxDate);\n      const month = startOfMonth(sanitisedFocusedDate);\n      return /*#__PURE__*/_jsx(Calendar, {\n        onMonthChange: this.handleMonthChange,\n        onDateClick: this.handleDateSelect,\n        month: month,\n        onDateKeyDown: this.handleDateKeyDown,\n        preventKeyboardFocus: this.state.preventKeyboardFocus,\n        focusedDate: sanitisedFocusedDate,\n        ...calendarProps,\n        minDate: sanitisedMinDate,\n        maxDate: sanitisedMaxDate,\n        selectionConfiguration: selectionConfiguration\n      });\n    }\n  }\n  return BpkCalendarContainer;\n};\nexport default withCalendarState(composeCalendar(BpkCalendarNav, BpkCalendarGridHeader, BpkCalendarGridWithTransition, BpkCalendarDate));\nexport { withCalendarState };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}